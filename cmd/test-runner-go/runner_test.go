package main

import (
	"os"
	"path/filepath"
	"testing"
	"time"
)

func TestParseJUnitXML(t *testing.T) {
	// Create temporary directory for test files
	tmpDir := t.TempDir()
	xmlPath := filepath.Join(tmpDir, "junit.xml")

	// Create test JUnit XML file
	xmlContent := `<?xml version="1.0" encoding="UTF-8"?>
<testsuites>
  <testsuite name="pkg1" tests="10" failures="2" skipped="1" time="1.234">
    <testcase name="Test1" classname="pkg1" time="0.1"></testcase>
    <testcase name="Test2" classname="pkg1" time="0.2">
      <failure message="assertion failed">Expected true, got false</failure>
    </testcase>
    <testcase name="Test3" classname="pkg1" time="0.3">
      <skipped message="skipped in short mode">Test skipped</skipped>
    </testcase>
  </testsuite>
  <testsuite name="pkg2" tests="5" failures="0" skipped="0" time="0.5">
    <testcase name="TestA" classname="pkg2" time="0.1"></testcase>
  </testsuite>
</testsuites>`

	err := os.WriteFile(xmlPath, []byte(xmlContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write test XML: %v", err)
	}

	// Parse the XML
	stats, err := parseJUnitXML(xmlPath)
	if err != nil {
		t.Fatalf("Failed to parse JUnit XML: %v", err)
	}

	// Verify statistics
	if stats.Total != 15 {
		t.Errorf("Expected total 15, got %d", stats.Total)
	}

	if stats.Failed != 2 {
		t.Errorf("Expected failed 2, got %d", stats.Failed)
	}

	if stats.Skipped != 1 {
		t.Errorf("Expected skipped 1, got %d", stats.Skipped)
	}

	expectedPassed := 15 - 2 - 1 // total - failed - skipped = 12
	if stats.Passed != expectedPassed {
		t.Errorf("Expected passed %d, got %d", expectedPassed, stats.Passed)
	}
}

func TestParseJUnitXML_NonexistentFile(t *testing.T) {
	_, err := parseJUnitXML("/nonexistent/file.xml")
	if err == nil {
		t.Error("Expected error for nonexistent file")
	}
}

func TestParseJUnitXML_InvalidXML(t *testing.T) {
	tmpDir := t.TempDir()
	xmlPath := filepath.Join(tmpDir, "invalid.xml")

	// Write invalid XML
	err := os.WriteFile(xmlPath, []byte("not valid xml"), 0644)
	if err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	_, err = parseJUnitXML(xmlPath)
	if err == nil {
		t.Error("Expected error for invalid XML")
	}
}

// Note: parseCoverage() requires actual Go coverage profile files and calls `go tool cover`.
// These tests would need actual coverage files generated by `go test -coverprofile`.
// We test the function indirectly through integration tests instead.

func TestParseCoverage_NonexistentFile(t *testing.T) {
	_, err := parseCoverage("/nonexistent/coverage.out")
	if err == nil {
		t.Error("Expected error for nonexistent file")
	}
}

func TestTestReport_Structure(t *testing.T) {
	// Test that TestReport can be created and has expected structure
	startTime := time.Now()
	report := &TestReport{
		Stage:     "unit",
		Name:      "test-run-123",
		Status:    "passed",
		StartTime: startTime,
		Duration:  12.5,
		TestStats: TestStats{
			Total:   100,
			Passed:  95,
			Failed:  3,
			Skipped: 2,
		},
		Coverage: Coverage{
			Percentage: 85.5,
			FilePath:   "/tmp/coverage.out",
		},
		OutputPath: "/tmp/junit.xml",
	}

	// Verify fields
	if report.Stage != "unit" {
		t.Errorf("Expected stage unit, got %s", report.Stage)
	}

	if report.Status != "passed" {
		t.Errorf("Expected status passed, got %s", report.Status)
	}

	if report.TestStats.Total != 100 {
		t.Errorf("Expected total 100, got %d", report.TestStats.Total)
	}

	if report.Coverage.Percentage != 85.5 {
		t.Errorf("Expected coverage 85.5, got %.1f", report.Coverage.Percentage)
	}
}

func TestJUnitTestSuites_Parsing(t *testing.T) {
	tmpDir := t.TempDir()
	xmlPath := filepath.Join(tmpDir, "multi-suite.xml")

	// Create test JUnit XML with multiple suites
	xmlContent := `<?xml version="1.0" encoding="UTF-8"?>
<testsuites>
  <testsuite name="suite1" tests="5" failures="1" skipped="0" time="1.0"></testsuite>
  <testsuite name="suite2" tests="10" failures="0" skipped="2" time="2.0"></testsuite>
  <testsuite name="suite3" tests="3" failures="0" skipped="0" time="0.5"></testsuite>
</testsuites>`

	err := os.WriteFile(xmlPath, []byte(xmlContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write test XML: %v", err)
	}

	stats, err := parseJUnitXML(xmlPath)
	if err != nil {
		t.Fatalf("Failed to parse JUnit XML: %v", err)
	}

	// Verify aggregation across suites
	expectedTotal := 5 + 10 + 3
	if stats.Total != expectedTotal {
		t.Errorf("Expected total %d, got %d", expectedTotal, stats.Total)
	}

	expectedFailed := 1 + 0 + 0
	if stats.Failed != expectedFailed {
		t.Errorf("Expected failed %d, got %d", expectedFailed, stats.Failed)
	}

	expectedSkipped := 0 + 2 + 0
	if stats.Skipped != expectedSkipped {
		t.Errorf("Expected skipped %d, got %d", expectedSkipped, stats.Skipped)
	}

	expectedPassed := expectedTotal - expectedFailed - expectedSkipped
	if stats.Passed != expectedPassed {
		t.Errorf("Expected passed %d, got %d", expectedPassed, stats.Passed)
	}
}

func TestJUnitTestSuites_EmptyFile(t *testing.T) {
	tmpDir := t.TempDir()
	xmlPath := filepath.Join(tmpDir, "empty.xml")

	// Create empty testsuites
	xmlContent := `<?xml version="1.0" encoding="UTF-8"?>
<testsuites>
</testsuites>`

	err := os.WriteFile(xmlPath, []byte(xmlContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write test XML: %v", err)
	}

	stats, err := parseJUnitXML(xmlPath)
	if err != nil {
		t.Fatalf("Failed to parse JUnit XML: %v", err)
	}

	// Should return zero stats
	if stats.Total != 0 || stats.Passed != 0 || stats.Failed != 0 || stats.Skipped != 0 {
		t.Errorf("Expected all zero stats, got %+v", stats)
	}
}

// Coverage percentage parsing is tested indirectly through integration tests
// since it requires actual Go coverage profile files.
